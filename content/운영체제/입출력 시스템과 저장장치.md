# 입출력장치
입출력장치는 메인보드에 있는 버스로 연결되며 다양한 주변장치는 저속 주변장치와 고속 주변장치로 구분된다.

1. 저속 주변장치  
저용량의 데이터가 오가고 데이터 전송률이 낮은 장치. ex) 키보드

2. 고속 주변장치
대용량의 데이터가 오가고 데이터 전송률이 높은 장치. ex) 그래픽카드, 하드디스크

버스에는 데이터가 지나다니는 통로인 채널이 있다. 4채널 버스는 4개의 주변장지가 동시에 데이터를 주고받을 수 있는 4차선 도로와 같다.  
주변장치는 저마다 전송 속도가 다르기 때문에, 속도가 비슷한 장치끼리 묶어 채널을 분리하여 병목현상을 줄인다.

## 입출력 버스의 구조
### 초기
- 모든 장치가 하나의 버스로 연결
- CPU가 작업을 하다 입출력명령을 만나면 입출력장치에서 직접 데이터를 가져온다 --> 풀링방식
- 입출력이 끝날 때 까지 다른작업 불가
### 입출력 제어기를 사용
- 모든 입출력을 입출력 제어기에 맡기는 구조.
- 2개의 채널(메인버스,입출력버스)로 나뉘는데, 메인버스는 CPU와 메모리가 사용하고 입출력버스는 주변장치가 사용한다.
- 입출력 제어기를 사용하면 CPU와 메모리의 작업과 주변장치의 작업이 분리되기에 작업 효율이 향상됨.
### 입출력 버스의 분리
- 고속 주변장치와 저속 주변장치의 속도차로 입출력버스의 병목현상이 심한것을 해결하기 위해 등장.
- 입출력 버스를 고속 입출력버스, 저속 입출력버스로 분리한다.
- 두 버스 사이의 데이터 전송은 채널 선택기가 관리한다.
- 그래픽 카드는 메인버스와 직접 연결된 그래픽 버스를 활용.
- 현재 컴퓨터는 메인버스/그래픽버스/고속,저속 입출력버스 활용

## 직접 메모리 접근(DMA)  
입출력 제어기가 데이터를 CPU의 명령 없이 메모리에 접근할 수 있도록 부여된 권한이다.
- 초기에는 CPU의 작업공간과 DMA의 작업공간이 겹치는것을 방지하기 위해 '입출력메모리' 라는 별도의 메모리에 보관하였지만 입출력메모리<-->메인메모리로 데이터를 옮기는 불필요한 작업을 수반한다.
- 현재는 메인메모리의 주소공간 중 일부를 DMA제어기에 할당하여 작업공간이 겹치는것을 막는다. 이를 메모리 맵 입출력이라고 부른다.

# 인터럽트
인터럽트란 주변장치의 입출력 요구나 하드웨어의 이상현상을 CPU에 알려준다.  
입출력작업이 완료되면 입출력제어기는 CPU에 인터럽트를 보내 신호를 준다.

### 외부 인터럽트(하드웨어 인터럽트)
입출력장치로부터 오는 인터럽트, 전원이상이나 기계적인 오류때문에 발생하는 인터럽트
### 내부 인터럽트(예외상황 인터럽트)
숫자를 0으로 나누거나 주소공간을 벗어나서 작업하는 것과 같이 프로세스의 오류와 관련된 인터럽트.

![image](https://user-images.githubusercontent.com/54929520/191709515-8c525e83-c995-497e-a90d-07d81687ae2e.png)

### 인터럽트 벡터
어떤 인터렙트가 발생했는지 파악하기 위해 사용하는 자료구조.
### 인터럽트 핸들러
인터럽트의 처리방법을 함수형태로 만들어놓은 것. 운영체제는 인터럽트가 발생하면 인터럽트 핸들러를 호출한다.
![image](https://user-images.githubusercontent.com/54929520/191709921-305e6a5e-9951-4d44-b145-56cf8e684fec.png)

# 버퍼
- 버퍼는 속도가 다른 두 장치의 속도 차이를 완화하는 역할이다. 느린 장치를 통해 들어오는 데이터를 버퍼에 모아 한번에 이동시키는 방식으로, 하드디스크나 CD-ROM 등 대부분 입출력장치는 버퍼를 사용하여 느린 속도를 보완한다.  
- 이중버퍼로 데이터를 가져가는 버퍼, 데이터를 담는 버퍼로 구성하면 버퍼 운용에 유리하다.
- 버퍼가 꽉 차야 데이터를 전송하므로 이를 주의하여 프로그래밍 해야한다.

# 저장장치
1. 하드디스크
![image](https://user-images.githubusercontent.com/54929520/191713015-43c4ea8f-b13f-46ac-88bd-3addccabddaf.png)

2. CD
![image](https://user-images.githubusercontent.com/54929520/191713247-3a56f0ac-86e6-4797-84dc-f2f5b17a815f.png)

## 데이터 전송 시간
1. 탐색시간(seek time)  
헤드가 현재 위치에서 그 트랙까지 이동하는 데 걸리는 시간
2. 회전 지연 시간(rotational latency time)  
트랙에서 원하는 섹터를 만날때까지 회전하는데 걸리는 시간
3. 전송 시간(transmission time)
섹터에 있는 데이터를 읽어 전송하는데 걸리는 시간

# 디스크 장치 관리
1. 파티션  
파티션은 디스크를 논리적으로 분할하는 작업이다.
![image](https://user-images.githubusercontent.com/54929520/191714494-ffd25f90-39f1-4c08-8de5-9e59f9190eae.png)
(c)의 여러 하드디스크를 하나처럼 통합하는 기능을 **마운트** 라고한다.
2. 포맷팅
디스크에 파일시스템을 탑재하고 디스크 표면을 초기화하여 사용할 수 있는 형태로 만드는 작업.  
빈 저장장치에 파일테이블을 탑재하는 것이 포매팅이다.
3. 조각모음  
하드디스크에서 파일을 저장했다 지우기를 반복하면 중간중간에 빈 공간이 생기는데 이를 조각화 또는 단편화라고 부른다. 조각이 많이 생기면 한 파일을 읽기 위해 여러곳을 돌아다녀야 하기 때문에 성능저하가 발생한다.
이러한 조각을 모으는 작업이 조각모음이다.

# 디스크 스케줄링
1. FCFS 스케줄링  
요청이 들어온 트랙 순서대로 서비스.
![image](https://user-images.githubusercontent.com/54929520/191715917-c78c05a0-e024-4117-bc36-c43f8554feb0.png)
 
2. SSTF 스케줄링  
현재 헤드의 위치에서 가장 가까운 트랙을 서비스.
![image](https://user-images.githubusercontent.com/54929520/191716045-3ba7be88-5b6a-4da5-90b2-bc6b46db9613.png)  
효율성은 좋지만 가장 안쪽이나 가장 바깥쪽에 있는 트랙은 서비스를 못받는 아사현상이 발생할 수 있다.

3. SCAN 스케줄링  
헤드가 한 방향으로만 움직이면서 맨 마지막 트랙에 도착할 때까지 요청받은 트랙을 서비스.
![image](https://user-images.githubusercontent.com/54929520/191717986-f59e1eae-8df7-4e54-8689-5c75e6ab9644.png)

4. C-SCAN 스케줄링  
헤드가 한쪽 방향으로 움직일 때는 요청받은 트랙을 서비스하고 반대방향으로 돌아올 때는 서비스하지 않는다.
![image](https://user-images.githubusercontent.com/54929520/191718277-fc1c3d73-a554-4286-a1bb-0ee1ace99ff8.png)

5. LOOK 스케줄링  
SCAN 스케줄링과 같지만 트랙의 끝까지 이동하지 않고 더이상 서비스할 트랙이 없으면 중간에서 방향을 바꾼다.
![image](https://user-images.githubusercontent.com/54929520/191718470-66d9cd5b-3a2d-41cd-b232-f5c23e9f2d50.png)

6. C-LOOK 스케줄링  
C-SCAN 스케줄링의 LOOK 버전이다.
![image](https://user-images.githubusercontent.com/54929520/191718557-47c70110-592a-42b0-9a08-446940ce6c9d.png)

7. SLTF 스케줄링  
최소 지연 우선 기법이라고 하며 위의 모든 기법은 탐색시간을 줄이는 기법이지만 SLTF기법은 다른 방식의 기법이다. 고정 헤드를 갖고있는 하드디스크에서 사용 가능하며 작업 요청이 들어온 섹터의 순서를 디스크가 회전하는 방향에 맞추어 정렬한다.
![image](https://user-images.githubusercontent.com/54929520/191719280-0359618c-6649-4b3d-b3f5-a6e3ebebd7ab.png)

# RAID 시스템
자동으로 백업하고 장애가 발생하면 이를 복구하는 시스템이다.

1. RAID 0(스트라이핑)   
![image](https://user-images.githubusercontent.com/54929520/191733160-26a31431-2355-41b7-a222-0dc7493c4bb4.png)  
디스크를 병렬로 연결하여 여러 개의 데이터를 여러 디스크에 동시에 저장하거나 가져올 수 있다.

2. RAID 1(미러링)  
![image](https://user-images.githubusercontent.com/54929520/191733325-61ed2637-c6b2-44a1-a7d5-3dd1b04463a4.png)  
짝수개의 디스크로 구성되고 같은 데이터를 여러 디스크에 저장한다.

3. RAID 2  
오류 교정 코드를 따로 관리하고 오류가 발생하면 이 코드를 이용하여 디스크를 복구한다. 또한 데이터가 비트단위로 저장된다.
![image](https://user-images.githubusercontent.com/54929520/191733696-2041a0f0-a377-4813-92f9-8c484c5a28ca.png)  
오류 교정 코드를 저장하기 위한 N-1개의 추가디스크를 필요로 한다.

4. RAID 3  
패리티비트를 사용하여 데이터를 복구한다.  
![image](https://user-images.githubusercontent.com/54929520/191734411-5fb8491d-0e01-463e-ad5d-6cffd8dd3ae5.png)  
3번째 디스크의 값은 0이다.  
![image](https://user-images.githubusercontent.com/54929520/191734693-d79bda35-e645-4617-a430-31eb371896ab.png)  
데이터는 섹터단위로 저장되고, 여러 섹터를 묶어 패리티비트를 생성한 후 오류가 없는 섹터를 이용하여 오류가 있는 섹터의 데이터를 복원하는 것을 'N-way 패리티 비트 방식' 이라고한다.

5. RAID 4  
![image](https://user-images.githubusercontent.com/54929520/191735791-976a7764-1171-438c-9094-e22767009fb4.png)  
RAID 3와 같은 방식이지만 처리하는 데이터가 블록단위인것이 다르다.  RAID 3방식은 데이터를 읽을때 모든 디스크가 동시에 동작해야하는 단점이 있는데, RAID 4 에서는 데이터를 하나의 디스크에 블록 단위로 저장하고 패리티 비트를 블록과 연결하여 구성한다.

6. RAID 5  
RAID 4는 모든 패리티비트가 하나의 디스크에 저장되어 병목현상이 발생한다. 또한 패리티비스가 저장된 디스크에 장애가 발생할 경우 복구가 안된다.
![image](https://user-images.githubusercontent.com/54929520/191736062-e58cea50-f9af-482c-b22b-9f858060f57a.png)  
RAID 5의 경우 패리티비트를 여러 디스크에 분산보관하여 병목현상을 완화하고, 패리티비트 디스크가 고장나는 문제도 해결한다.  
RAID5 5에서는 패리티비트를 해당 데이터가 없는 디스크에 보관한다.

7. RAID 6  
![image](https://user-images.githubusercontent.com/54929520/191736581-8ec4d25f-8af1-4b1e-b8ca-f4a0c0ca26ff.png)  
RAID 5과 같은 방식이지만 패리티비트가 2개이다. RAID 5는 디스크 2개에 동시에 장애가 발생할경우 복구가 불가능하지만 RAID 6는 패리티비트를 2개로 구성하여 분산하여 디스크 2개의 장애를 복구할 수 있다.

8. RAID 01, RAID 10  
![image](https://user-images.githubusercontent.com/54929520/191736777-59d0a018-f5f7-4cf5-827d-75d5331ba864.png)  
하드디스크의 가격이 저렴해지면서 디스크의 수보다 빠른 입출력과 복구에 중점을 둔 RAID 시스템이 등장하였다.
차이점은 RAID 01은 하나의 디스크를 복구하려면 모든 디스크가 멈춰야하고 RAID 10은 반대의 디스크를 멈추지 않아도 복구가 가능하다.

9. RAID 50, RAID 60  
![image](https://user-images.githubusercontent.com/54929520/191739580-cbd533fc-20ce-4ad0-bbcc-1b5c71359607.png)  
